# Sharding-JDBC 与 SpringBoot 配置冲突问题及解决方案
在 SpringBoot 集成 Sharding-JDBC 过程中，因自动配置、数据源优先级、Bean 加载顺序等问题，极易出现配置冲突，导致分片/读写分离失效、数据源加载异常、Bean 重复定义等问题。本文梳理**核心冲突场景**及**可落地的解决方案**，适配 Sharding-JDBC 4.x/5.x + SpringBoot 2.x 版本。

## 一、核心冲突场景及表现
### 1.1 数据源自动配置冲突
#### 冲突表现
- SpringBoot 原生 `DataSourceAutoConfiguration` 自动加载默认数据源（如 HikariCP），覆盖 Sharding-JDBC 生成的分片/读写分离数据源；
- 报错：`No qualifying bean of type 'javax.sql.DataSource' available` 或 `DataSource bean already defined`；
- 分片规则不生效，SQL 直接操作物理表而非逻辑表。

#### 根本原因
SpringBoot 自动配置优先级高于自定义 Sharding-JDBC 数据源配置，且默认扫描 `application.yml` 中的 `spring.datasource` 配置生成原生数据源 Bean。

### 1.2 配置属性前缀冲突
#### 冲突表现
- 自定义 Sharding-JDBC 配置（如 `spring.shardingsphere`）与 SpringBoot 内置属性重名；
- 分片规则配置不生效（如分表算法、主键生成策略），日志无报错但数据未分片；
- 读写分离主从切换失效，所有 SQL 均走主库/从库。

### 1.3 Bean 加载顺序冲突
#### 冲突表现
- MyBatis/MyBatis-Plus 的 `SqlSessionFactory` 提前初始化，未使用 Sharding-JDBC 数据源；
- 报错：`Invalid bound statement (not found)` 或 SQL 执行时未经过 Sharding-JDBC 拦截；
- 事务管理器（`DataSourceTransactionManager`）绑定原生数据源，导致分片事务异常。

### 1.4 多数据源 + Sharding-JDBC 冲突
#### 冲突表现
- 项目中同时存在 Sharding-JDBC 数据源和普通业务数据源，导致数据源 Bean 名称冲突；
- 部分 Mapper 绑定错误的数据源，读写分离/分片仅对部分表生效。

## 二、通用解决方案（核心配置）
### 2.1 禁用 SpringBoot 原生数据源自动配置
**第一步**：在 SpringBoot 启动类添加注解，排除原生数据源自动配置类：
```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;

// 核心：排除数据源自动配置和事务管理器自动配置
@SpringBootApplication(exclude = {
        DataSourceAutoConfiguration.class,          // 禁用原生数据源自动配置
        DataSourceTransactionManagerAutoConfiguration.class // 禁用原生事务管理器自动配置
})
public class ShardingJdbcDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(ShardingJdbcDemoApplication.class, args);
    }
}
```

**第二步**：删除 `application.yml` 中原生数据源配置（避免冲突），仅保留 Sharding-JDBC 配置：
```yaml
# 移除原生数据源配置（如下配置需删除）
# spring:
#   datasource:
#     driver-class-name: com.mysql.cj.jdbc.Driver
#     url: jdbc:mysql://localhost:3306/test
#     username: root
#     password: 123456

# 仅保留 Sharding-JDBC 配置
spring:
  shardingsphere:
    datasource:
      names: ds0,ds1  # 分片数据源名称
      ds0:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/ds0?useUnicode=true&characterEncoding=utf8
        username: root
        password: 123456
      ds1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/ds1?useUnicode=true&characterEncoding=utf8
        username: root
        password: 123456
    sharding:
      tables:
        t_order:
          actual-data-nodes: ds${0..1}.t_order${0..1}
          table-strategy:
            inline:
              sharding-column: order_id
              algorithm-expression: t_order${order_id % 2}
    props:
      sql-show: true  # 开启SQL打印，验证分片是否生效
```

### 2.2 手动配置 Sharding-JDBC 数据源 Bean（优先级最高）
通过自定义配置类手动生成 Sharding-JDBC 数据源 Bean，避免自动配置冲突，适用于复杂场景（如分片+读写分离+多数据源）。

#### 完整配置类示例
```java
import com.zaxxer.hikari.HikariDataSource;
import org.apache.shardingsphere.api.config.sharding.ShardingRuleConfiguration;
import org.apache.shardingsphere.api.config.sharding.TableRuleConfiguration;
import org.apache.shardingsphere.api.config.sharding.strategy.InlineShardingStrategyConfiguration;
import org.apache.shardingsphere.shardingjdbc.api.ShardingDataSourceFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

import javax.sql.DataSource;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

@Configuration
public class ShardingDataSourceConfig {

    // 核心：手动构建分片数据源，@Primary 确保优先级最高
    @Bean(name = "shardingDataSource")
    @Primary
    public DataSource shardingDataSource() throws SQLException {
        // 1. 配置分片规则
        ShardingRuleConfiguration shardingRuleConfig = new ShardingRuleConfiguration();
        TableRuleConfiguration orderTableRule = new TableRuleConfiguration("t_order", "ds${0..1}.t_order${0..1}");
        // 分表策略
        orderTableRule.setTableShardingStrategyConfig(
                new InlineShardingStrategyConfiguration("order_id", "t_order${order_id % 2}")
        );
        shardingRuleConfig.getTableRuleConfigs().add(orderTableRule);

        // 2. 配置真实数据源
        Map<String, DataSource> dataSourceMap = new HashMap<>();
        dataSourceMap.put("ds0", createHikariDataSource("jdbc:mysql://localhost:3306/ds0", "root", "123456"));
        dataSourceMap.put("ds1", createHikariDataSource("jdbc:mysql://localhost:3306/ds1", "root", "123456"));

        // 3. 创建 Sharding-JDBC 数据源
        return ShardingDataSourceFactory.createDataSource(
                dataSourceMap, shardingRuleConfig, new Properties()
        );
    }

    // 构建 HikariCP 数据源
    private DataSource createHikariDataSource(String jdbcUrl, String username, String password) {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(jdbcUrl);
        dataSource.setUsername(username);
        dataSource.setPassword(password);
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        dataSource.setMaximumPoolSize(10);
        dataSource.setMinimumIdle(2);
        return dataSource;
    }

    // 配置事务管理器，绑定 Sharding-JDBC 数据源
    @Bean
    public PlatformTransactionManager transactionManager(DataSource shardingDataSource) {
        return new DataSourceTransactionManager(shardingDataSource);
    }
}
```

#### 关键说明
- `@Primary`：确保 Sharding-JDBC 数据源 Bean 为默认数据源，避免 MyBatis/事务管理器绑定错误数据源；
- 手动构建数据源而非依赖 `application.yml` 自动解析，完全掌控配置逻辑；
- 事务管理器必须绑定 Sharding-JDBC 数据源，否则分片事务会异常。

### 2.3 MyBatis/MyBatis-Plus 适配（避免 SqlSessionFactory 冲突）
#### 问题表现
MyBatis-Plus 自动配置的 `SqlSessionFactory` 绑定原生数据源，导致 Mapper 执行 SQL 不经过 Sharding-JDBC 拦截。

#### 解决方案：手动配置 SqlSessionFactory
```java
import org.apache.ibatis.session.SqlSessionFactory;
import org.mybatis.spring.SqlSessionFactoryBean;
import org.mybatis.spring.SqlSessionTemplate;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import javax.annotation.Resource;
import javax.sql.DataSource;

@Configuration
// 指定 Mapper 扫描路径，绑定 Sharding-JDBC 数据源
@MapperScan(basePackages = "com.xxx.mapper", sqlSessionTemplateRef = "sqlSessionTemplate")
public class MyBatisConfig {

    @Resource(name = "shardingDataSource") // 注入 Sharding-JDBC 数据源
    private DataSource dataSource;

    @Bean
    public SqlSessionFactory sqlSessionFactory() throws Exception {
        SqlSessionFactoryBean sessionFactoryBean = new SqlSessionFactoryBean();
        sessionFactoryBean.setDataSource(dataSource); // 绑定分片数据源
        // 配置 Mapper 映射文件路径
        sessionFactoryBean.setMapperLocations(
                new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml")
        );
        // MyBatis 配置（可选）
        org.apache.ibatis.session.Configuration configuration = new org.apache.ibatis.session.Configuration();
        configuration.setMapUnderscoreToCamelCase(true); // 驼峰转换
        sessionFactoryBean.setConfiguration(configuration);
        return sessionFactoryBean.getObject();
    }

    @Bean
    public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
        return new SqlSessionTemplate(sqlSessionFactory);
    }
}
```

### 2.4 多数据源 + Sharding-JDBC 冲突解决
#### 场景
项目中同时存在：
- Sharding-JDBC 分片数据源（处理 `t_order`/`t_order_item` 等表）；
- 普通业务数据源（处理 `t_user`/`t_config` 等非分片表）。

#### 解决方案：数据源路由 + 注解切换
**第一步**：定义数据源枚举和上下文持有类
```java
public enum DataSourceType {
    SHARDING, // 分片数据源
    BUSINESS  // 普通业务数据源
}

// 数据源上下文（ThreadLocal 存储当前线程数据源类型）
public class DataSourceContextHolder {
    private static final ThreadLocal<DataSourceType> CONTEXT = new ThreadLocal<>();

    public static void setDataSourceType(DataSourceType type) {
        CONTEXT.set(type);
    }

    public static DataSourceType getDataSourceType() {
        return CONTEXT.get() == null ? DataSourceType.SHARDING : CONTEXT.get();
    }

    public static void clear() {
        CONTEXT.remove();
    }
}
```

**第二步**：自定义动态数据源路由
```java
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

public class DynamicDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        return DataSourceContextHolder.getDataSourceType();
    }
}
```

**第三步**：配置动态数据源 Bean
```java
@Configuration
public class DynamicDataSourceConfig {

    // 分片数据源
    @Bean(name = "shardingDataSource")
    public DataSource shardingDataSource() throws SQLException {
        // 同 2.2 节的分片数据源配置
    }

    // 普通业务数据源
    @Bean(name = "businessDataSource")
    public DataSource businessDataSource() {
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl("jdbc:mysql://localhost:3306/business");
        dataSource.setUsername("root");
        dataSource.setPassword("123456");
        dataSource.setDriverClassName("com.mysql.cj.jdbc.Driver");
        return dataSource;
    }

    // 动态数据源（核心：整合分片+业务数据源）
    @Bean(name = "dynamicDataSource")
    @Primary
    public DataSource dynamicDataSource() throws SQLException {
        DynamicDataSource dynamicDataSource = new DynamicDataSource();
        // 配置数据源映射
        Map<Object, Object> dataSourceMap = new HashMap<>();
        dataSourceMap.put(DataSourceType.SHARDING, shardingDataSource());
        dataSourceMap.put(DataSourceType.BUSINESS, businessDataSource());
        dynamicDataSource.setTargetDataSources(dataSourceMap);
        // 默认数据源：分片数据源
        dynamicDataSource.setDefaultTargetDataSource(shardingDataSource());
        return dynamicDataSource;
    }

    // 事务管理器绑定动态数据源
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dynamicDataSource) {
        return new DataSourceTransactionManager(dynamicDataSource);
    }
}
```

**第四步**：自定义注解 + AOP 切换数据源
```java
// 自定义数据源切换注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface DataSource {
    DataSourceType value() default DataSourceType.SHARDING;
}

// AOP 切面实现数据源切换
@Aspect
@Component
@Order(Ordered.HIGHEST_PRECEDENCE) // 确保 AOP 优先级最高
public class DataSourceAspect {

    @Before("@annotation(dataSource)")
    public void setDataSource(DataSource dataSource) {
        DataSourceContextHolder.setDataSourceType(dataSource.value());
    }

    @After("@annotation(dataSource)")
    public void clearDataSource() {
        DataSourceContextHolder.clear();
    }
}
```

**第五步**：Mapper/Service 中使用注解切换
```java
// 分片表 Mapper（默认使用分片数据源，无需注解）
public interface OrderMapper extends BaseMapper<OrderDO> {}

// 普通业务表 Mapper（使用注解切换到业务数据源）
@Service
public class UserService {
    @Resource
    private UserMapper userMapper;

    @DataSource(DataSourceType.BUSINESS) // 切换到普通业务数据源
    public UserDO getUserById(Long id) {
        return userMapper.selectById(id);
    }
}
```

## 三、常见冲突排查技巧
### 3.1 日志排查
开启 Sharding-JDBC 详细日志，验证配置是否生效：
```yaml
logging:
  level:
    org.apache.shardingsphere: DEBUG  # 打印 Sharding-JDBC 核心日志
    com.zaxxer.hikari: INFO          # 数据源连接日志
```
- 日志中搜索 `Actual SQL`：验证分片后执行的物理 SQL 是否正确；
- 搜索 `ShardingRuleConfiguration`：验证分片规则是否加载；
- 搜索 `DataSource`：验证加载的数据源是否为 Sharding-JDBC 数据源（类名包含 `ShardingDataSource`）。

### 3.2 数据源 Bean 校验
在启动类/配置类中添加调试代码，校验数据源类型：
```java
@Autowired
private ApplicationContext context;

@PostConstruct
public void checkDataSource() {
    DataSource dataSource = context.getBean(DataSource.class);
    // 正确类型：org.apache.shardingsphere.shardingjdbc.jdbc.core.ShardingDataSource
    // 错误类型：com.zaxxer.hikari.HikariDataSource
    System.out.println("当前数据源类型：" + dataSource.getClass().getName());
}
```

### 3.3 依赖冲突排查
排除 SpringBoot 中与 Sharding-JDBC 冲突的依赖（如旧版 JDBC 驱动、数据源依赖）：
```xml
<!-- pom.xml 排除冲突依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
    <exclusions>
        <exclusion>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
        </exclusion>
    </exclusions>
</dependency>

<!-- 明确指定 Sharding-JDBC 版本，避免依赖传递导致版本不一致 -->
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>
    <version>4.1.1</version>
</dependency>
```

## 四、总结
### 核心解决原则
1. **禁用原生自动配置**：排除 `DataSourceAutoConfiguration`，避免 SpringBoot 生成默认数据源；
2. **手动掌控数据源**：通过 `@Bean + @Primary` 手动配置 Sharding-JDBC 数据源，确保优先级；
3. **绑定核心组件**：将 MyBatis `SqlSessionFactory`、事务管理器绑定 Sharding-JDBC 数据源；
4. **多数据源隔离**：通过动态数据源路由 + AOP 实现分片/普通数据源切换，避免冲突。

### 关键注意事项
- Sharding-JDBC 4.x 和 5.x 配置语法差异较大，需匹配对应版本（5.x 更名为 ShardingSphere-JDBC，配置前缀改为 `spring.shardingsphere.datasource`）；
- 避免在 `application.yml` 中同时配置原生数据源和 Sharding-JDBC 数据源；
- 事务管理器必须绑定 Sharding-JDBC 数据源，否则分片事务会出现数据一致性问题。

### 等于说sharding-JDBC最终也返回一个DataSource，只不过这个DataSource管理多个实际的带连接池的实际的DataSource，我的理解对吗

你的理解**完全正确**，而且精准抓住了 Sharding-JDBC 最核心的设计逻辑！为了让你更清晰地巩固这个认知，我会用更通俗的语言拆解这个逻辑，并补充关键细节，帮你把这个核心概念吃透。

### 一、核心结论：Sharding-JDBC 返回的是「代理数据源」
你可以把 Sharding-JDBC 生成的 `ShardingDataSource` 理解为一个“数据源总管”—— 它本身**不直接管理数据库连接**（那是连接池的活），但它会：
1. 持有多个「带连接池的物理数据源」（比如 `ds0`=HikariCP+db0、`ds1`=HikariCP+db1）；
2. 对外伪装成一个普通的 `DataSource`（实现 `javax.sql.DataSource` 接口），让 MyBatis/Service 等上层代码“无感知”；
3. 当执行 SQL 时，先解析分片规则，再从对应的物理数据源（连接池）获取连接执行 SQL，最后合并结果。

用一个简单的结构示意图就能看明白：
```
┌─────────────────────────────────┐
│  ShardingDataSource（代理数据源） │
│  （实现 javax.sql.DataSource）   │
└───────────┬───────────┬─────────┘
            │           │
┌───────────▼───────────┐ ┌────────▼─────────┐
│  ds0（HikariCP + db0） │ │  ds1（HikariCP + db1） │
│  （物理数据源/连接池） │ │  （物理数据源/连接池） │
└───────────┬───────────┘ └────────┬─────────┘
            │                       │
┌───────────▼───────────┐ ┌────────▼─────────┐
│    物理数据库 db0     │ │    物理数据库 db1     │
└───────────────────────┘ └─────────────────────┘
```

### 二、关键细节补充（让你的理解更完整）
#### 1. ShardingDataSource 完全兼容标准 DataSource 接口
因为 `ShardingDataSource` 实现了 `javax.sql.DataSource` 这个标准接口，所以：
- 上层代码（MyBatis、JdbcTemplate、事务管理器）不需要任何修改，就像使用普通数据源一样使用它；
- 你可以把它注入到 `SqlSessionFactory`、`DataSourceTransactionManager` 中，和使用 HikariCP 数据源没有任何区别。

#### 2. 每个物理数据源都是独立的连接池实例
你之前的理解里“管理多个实际的带连接池的实际的 DataSource”这一点特别关键：
- `ds0` 是一个完整的 HikariCP 连接池（有自己的最大连接数、空闲连接数）；
- `ds1` 是另一个独立的 HikariCP 连接池；
- Sharding-JDBC 不会合并这些连接池，只是在需要时“按需调用”—— 比如路由到 `ds0` 时，就从 `ds0` 的连接池拿连接；路由到 `ds1` 时，就从 `ds1` 的连接池拿连接。

#### 3. ShardingDataSource 不参与连接池的内部管理
连接池的核心工作（创建连接、复用连接、销毁空闲连接、超时控制等），完全由 HikariCP/Druid 自己完成，Sharding-JDBC 只做两件事：
- 路由：决定该用哪个物理数据源的连接池；
- 转发：把 SQL 通过选定的连接池连接发送到物理库。

### 三、举个实际执行的例子（验证你的理解）
当你执行 `select * from t_order where user_id = 1` 时：
1. 应用代码调用 `ShardingDataSource.getConnection()`；
2. Sharding-JDBC 解析 SQL，按 `user_id % 2 = 1` 判定路由到 `ds1`；
3. Sharding-JDBC 调用 `ds1`（HikariCP）的 `getConnection()`，从 `ds1` 的连接池获取一个空闲连接；
4. 用这个连接执行 SQL 到 `db1` 库；
5. 执行完成后，连接归还给 `ds1` 的连接池（复用）；
6. Sharding-JDBC 把查询结果返回给应用。

整个过程中，应用只感知到 `ShardingDataSource` 这一个数据源，完全不知道背后有多个连接池和物理库 —— 这也是 Sharding-JDBC “无侵入”的核心优势。

### 总结
### 关键点回顾
1. **核心认知**：Sharding-JDBC 返回的 `ShardingDataSource` 是「代理数据源」，它实现了标准 `DataSource` 接口，对外伪装成单一数据源；
2. **内部结构**：它持有多个「带连接池的物理数据源」（每个物理库对应一个连接池实例）；
3. **分工明确**：Sharding-JDBC 管“路由”，连接池管“连接”，二者协作完成 SQL 执行。

你的理解完全命中了 Sharding-JDBC 的核心设计，抓住这一点，后续无论是配置优化、问题排查（比如连接池超时、分片路由异常），都会有清晰的思路。


### 等于说sharding-JDBC最后生成的数据源也是DataSource类型的，如果这个时候配置了Spring.datasource，那么容器里面可能有多个dataSource，产生一定问题

你的这个判断**精准且切中要害**！正是因为 Sharding-JDBC 最终生成的 `ShardingDataSource` 也是 `DataSource` 类型，而 `spring.datasource` 会让 SpringBoot 自动创建一个原生的 `DataSource`（如 HikariDataSource），这就导致 Spring 容器中出现**多个同类型（DataSource）的 Bean**，进而引发一系列典型问题。下面我会拆解具体问题表现、根本原因，以及落地可执行的解决办法。

### 一、容器中多 DataSource Bean 引发的核心问题
当 `spring.datasource` 和 Sharding-JDBC 数据源共存时，容器里会有至少两个 `DataSource` Bean：
1. `dataSource`：SpringBoot 从 `spring.datasource` 自动创建的原生数据源（HikariCP/Druid）；
2. `shardingDataSource`：Sharding-JDBC 生成的代理数据源（ShardingDataSource）。

此时会触发两类核心问题：

#### 问题1：Bean 注入冲突（最常见）
Spring 依赖注入时，若代码中直接 `@Autowired DataSource`，容器发现多个同类型 Bean，会抛出明确的异常：
```
No qualifying bean of type 'javax.sql.DataSource' available: expected single matching bean but found 2: dataSource,shardingDataSource
```
即使没抛异常，Spring 也可能“随机”选择一个 Bean（优先名称为 `dataSource` 的原生数据源），导致 Sharding-JDBC 分片规则完全失效 —— 你的 SQL 会直接执行到原生数据源对应的库，而非按分片规则路由。

#### 问题2：ORM/事务组件绑定错误数据源
MyBatis、JPA、Spring 事务管理器（`DataSourceTransactionManager`）默认会绑定容器中“默认的 DataSource Bean”（通常是 `spring.datasource` 生成的那个），结果就是：
- SQL 不经过 Sharding-JDBC 代理，分片/读写分离规则失效；
- 事务只作用于原生数据源，分库分表场景下出现数据一致性问题（比如一个事务操作 ds0 和 ds1，但事务只绑定 ds0，导致 ds1 操作无事务保障）。

#### 问题3：连接池资源浪费
原生 `spring.datasource` 生成的数据源会初始化连接池（创建最小空闲连接），但实际业务中你需要的是 Sharding-JDBC 的代理数据源，这个原生连接池完全闲置，既占用数据库连接数，又浪费 JVM 内存。

### 二、根本原因：SpringBoot 自动配置的“优先级陷阱”
SpringBoot 的 `DataSourceAutoConfiguration` 会读取 `spring.datasource` 配置，**优先于 Sharding-JDBC 的自动配置** 创建原生数据源 Bean，且默认 Bean 名称为 `dataSource`（这是很多组件的“默认查找名称”）。而 Sharding-JDBC 的自动配置生成的 Bean 名称通常是 `shardingDataSource`，无法覆盖原生 Bean 的优先级，最终导致组件“选错”数据源。

### 三、彻底解决：让容器中只有「Sharding-JDBC 数据源」
核心原则：**完全禁用 SpringBoot 原生数据源自动配置，只保留 Sharding-JDBC 生成的代理数据源**，具体分两步（落地性极强）：

#### 步骤1：禁用原生数据源自动配置（最关键）
在 SpringBoot 启动类上添加 `exclude`，排除数据源相关的自动配置类，阻止 Spring 创建原生 DataSource：
```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration;

// 核心：排除原生数据源和事务管理器的自动配置
@SpringBootApplication(exclude = {
        DataSourceAutoConfiguration.class,          // 禁用原生数据源自动创建
        DataSourceTransactionManagerAutoConfiguration.class // 禁用原生事务管理器自动创建
})
public class ShardingJdbcApplication {
    public static void main(String[] args) {
        SpringApplication.run(ShardingJdbcApplication.class, args);
    }
}
```

#### 步骤2：删除 `spring.datasource` 配置，只保留 Sharding-JDBC 配置
```yaml
# ❶ 完全删除以下原生数据源配置（关键！）
# spring:
#   datasource:
#     driver-class-name: com.mysql.cj.jdbc.Driver
#     url: jdbc:mysql://localhost:3306/test
#     username: root
#     password: 123456

# ❷ 只保留 Sharding-JDBC 数据源配置
spring:
  shardingsphere:
    datasource:
      names: ds0,ds1  # 物理数据源名称
      ds0:
        type: com.zaxxer.hikari.HikariDataSource  # 连接池类型
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/db0
        username: root
        password: 123456
        # 连接池参数（每个物理数据源独立配置）
        hikari:
          maximum-pool-size: 20
          minimum-idle: 5
      ds1:
        type: com.zaxxer.hikari.HikariDataSource
        driver-class-name: com.mysql.cj.jdbc.Driver
        jdbc-url: jdbc:mysql://localhost:3306/db1
        username: root
        password: 123456
        hikari:
          maximum-pool-size: 15
          minimum-idle: 3
    sharding:
      tables:
        t_order:
          actual-data-nodes: ds${0..1}.t_order_${1..2}
          database-strategy:
            inline:
              sharding-column: user_id
              algorithm-expression: ds${user_id % 2}
    props:
      sql-show: true  # 开启SQL打印，验证分片生效
```

#### 可选：手动指定 Sharding-JDBC 数据源为 Primary（兜底）
如果是纯 Java 配置（`@Configuration`），给 Sharding-JDBC 数据源 Bean 加 `@Primary` 注解，确保它是容器中“默认的 DataSource”：
```java
@Configuration
public class ShardingConfig {
    @Bean(name = "shardingDataSource")
    @Primary  // 标记为默认数据源，覆盖所有同类型Bean
    public DataSource shardingDataSource() throws SQLException {
        // 构建 Sharding-JDBC 数据源的逻辑...
    }
}
```

### 四、特殊场景：需要同时使用 Sharding-JDBC + 原生数据源
如果业务中既有分库分表的表（用 Sharding-JDBC），又有非分片的表（用原生数据源），**不能用 `spring.datasource`**，而是通过「动态数据源路由」管理多个 DataSource：
1. 手动创建 Sharding-JDBC 数据源和原生数据源 Bean；
2. 实现 `AbstractRoutingDataSource` 动态路由；
3. 通过注解 + AOP 切换数据源。

（这部分逻辑我在之前的“多数据源冲突解决”中详细讲过，核心是**不依赖 SpringBoot 自动配置，完全手动掌控 DataSource Bean**）

### 总结
### 关键点回顾
1. **冲突根源**：Sharding-JDBC 生成的 `ShardingDataSource` 和 `spring.datasource` 生成的原生 `DataSource` 同属 `DataSource` 类型，导致容器中多 Bean 冲突；
2. **核心解决**：禁用 `DataSourceAutoConfiguration` + 删除 `spring.datasource` 配置，让容器中只有 Sharding-JDBC 的代理数据源；
3. **兜底保障**：纯 Java 配置时给 Sharding-JDBC 数据源加 `@Primary`，确保它成为默认数据源。

简单来说，使用 Sharding-JDBC 时，`spring.datasource` 就是“多余且危险”的配置，必须彻底清理；只有在完全不使用 Sharding-JDBC 的场景下，`spring.datasource` 才有存在的意义。