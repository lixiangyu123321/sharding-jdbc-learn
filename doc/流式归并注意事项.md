你关注的 Sharding-JDBC 流式归并（Stream Merging）是其结果归并的核心模式之一，主要用于处理大数据量查询（如分页、排序、聚合）时的结果集合并，避免全量加载数据到内存导致 OOM。下面我会从**核心原理、关键注意事项、避坑方案**三个维度，结合实操场景讲清楚流式归并的使用要点。

### 一、先理解流式归并的核心逻辑
Sharding-JDBC 的结果归并有两种模式：
- **内存归并**：将所有分片的结果集全量加载到内存后再排序/聚合（适合小数据集）；
- **流式归并**：逐行读取各分片的结果集，边读取边归并（适合大数据集，核心是“按需加载”）。

流式归并仅支持 **ORDER BY + 分页（LIMIT/OFFSET）** 场景，核心是利用各分片已排序的结果，通过“游标遍历”逐行合并，避免内存溢出。

---

## 二、流式归并的核心注意事项（必看）
### 1. 前提条件：必须保证分片结果“预排序”
流式归并的**核心前提**是：每个分片返回的结果集已经按 `ORDER BY` 字段排好序，否则归并结果会错乱。
- ✅ 正确做法：`ORDER BY` 字段需包含**分片键**，或在分片库的表上建立该字段的索引，确保每个分片执行 `SELECT ... ORDER BY xxx LIMIT ...` 时返回有序结果；
- ❌ 错误示例：仅在应用层指定 `ORDER BY`，但分片库的查询未排序，流式归并会直接出错。

**配置/SQL 示例**：
```sql
-- 正确：每个分片都会先按 create_time 排序，再返回分页结果
SELECT * FROM t_order 
WHERE user_id = 100 
ORDER BY create_time DESC 
LIMIT 10 OFFSET 0;

-- 关键：t_order 表需在每个分片库上建立 create_time 索引
CREATE INDEX idx_order_create_time ON t_order(create_time);
```

### 2. 分页场景：OFFSET 越大，性能越低（核心坑点）
流式归并处理 `LIMIT m OFFSET n` 时，需要逐行读取前 `n` 条数据并丢弃，仅保留 `m` 条结果：
- 当 `OFFSET = 10000` 时，Sharding-JDBC 需从所有分片读取前 10000 行数据，仅返回最后 10 行；
- 解决方案：
    1. 用**游标分页**替代 OFFSET 分页（基于上次最后一条数据的 `create_time`/`id` 作为条件）：
       ```sql
       -- 优化后：无需 OFFSET，直接基于上次的最后时间过滤
       SELECT * FROM t_order 
       WHERE user_id = 100 AND create_time < '2024-01-01 00:00:00'
       ORDER BY create_time DESC 
       LIMIT 10;
       ```
    2. 限制单次分页的 OFFSET 最大值（如不超过 1000），超过则提示“请缩小查询范围”。

### 3. 数据类型兼容：ORDER BY 字段类型必须一致
各分片表的 `ORDER BY` 字段类型需完全相同（如都是 `datetime`/`bigint`），否则流式归并时的比较逻辑会出错：
- ❌ 错误场景：分片0的 `create_time` 是 `varchar`，分片1的是 `datetime`，归并排序会乱序；
- ✅ 规范：分库分表时，所有分片表的结构（字段类型、索引）必须完全一致。

### 4. 聚合函数：流式归并不支持复杂聚合
流式归并仅支持 **ORDER BY + LIMIT/OFFSET**，不支持 `SUM/COUNT/MAX/MIN` 等聚合函数的流式处理：
- 若查询包含聚合函数，Sharding-JDBC 会自动降级为**内存归并**，需注意：
    1. 聚合查询的结果集不能过大（否则 OOM）；
    2. 聚合字段建议建立索引，减少分片查询耗时。

### 5. 数据库游标：控制结果集获取方式
流式归并依赖数据库的游标（ResultSet）逐行读取，需注意：
- 禁用连接池的“结果集缓存”（如 HikariCP 无此问题，Druid 需配置）：
  ```yaml
  # Druid 连接池配置：禁用结果集缓存，适配流式归并
  spring:
    datasource:
      druid:
        pool-prepared-statements: false
        max-open-prepared-statements: -1
  ```
- 避免长时间持有游标：流式归并时，数据库连接会被占用直到结果集读取完成，需控制单次查询的耗时，避免连接池耗尽。

### 6. 分片数量：过多分片会降低流式归并效率
流式归并需要同时持有所有分片的结果集游标，分片数量越多：
- 占用的数据库连接数越多（每个分片一个连接）；
- 归并时的比较逻辑耗时越长；
- 建议：单查询的分片数不超过 20，超过则考虑按业务维度拆分查询。

### 7. 空结果/异常分片：做好兜底处理
若部分分片返回空结果，或查询抛出异常，流式归并不会自动终止，需：
1. 配置 Sharding-JDBC 的异常处理策略：
   ```yaml
   spring:
     shardingsphere:
       props:
         sql-executor-fail-over: true  # 某分片执行失败时，尝试其他分片（仅适用于读请求）
   ```
2. 业务层捕获 `SQLExecutionException`，处理分片查询异常。

---

## 三、流式归并的性能优化建议
| 优化点                | 具体操作                                                                 |
|-----------------------|--------------------------------------------------------------------------|
| 索引优化              | 为 `ORDER BY` 字段建立**联合索引**（如 `idx_user_create_time (user_id, create_time)`），减少分片查询耗时 |
| 分片过滤              | 尽可能在 WHERE 条件中加入分片键（如 `user_id`），减少参与归并的分片数量 |
| 结果集大小控制        | 单次分页的 LIMIT 不超过 100，避免单次读取过多数据                       |
| 连接池配置            | 增大连接池最大连接数（应对多分片同时查询），设置合理的连接超时时间       |
| 禁用不必要的功能      | 关闭 SQL 日志打印（`sql-show: false`），减少 IO 开销                     |

---

### 总结
1. **核心前提**：流式归并仅适用于 `ORDER BY + LIMIT/OFFSET` 场景，且分片结果必须预排序（字段类型一致+索引）；
2. **性能坑点**：OFFSET 越大性能越差，优先用游标分页替代；分片数量过多会占用大量连接，需控制分片数；
3. **避坑关键**：禁用结果集缓存、做好异常兜底、避免复杂聚合（聚合会降级为内存归并）；
4. **优化核心**：通过索引和分片过滤减少分片查询/归并的压力，控制单次结果集大小。

如果你的业务场景是“海量订单的分页查询”，我可以帮你设计针对性的流式归并配置（含索引、SQL、Sharding-JDBC 配置），避免 OOM 和性能问题。