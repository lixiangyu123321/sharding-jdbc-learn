你这个问题直击核心！确实，**刷新 MyBatis 组件（替换 SqlSessionFactory 中的数据源）的操作，比关闭旧数据源更早执行，这才是导致正在进行的请求失败的最大风险点**——我之前的回答聚焦在旧数据源关闭，但忽略了“数据源替换”这个更早的风险环节。下面我会拆解这个风险的本质，并给出完整的“无感知切换”改造方案。

### 一、先理清风险的核心逻辑
你的代码执行流程是：
```
1. 注册新数据源 Bean → 
2. 刷新 MyBatis 组件（替换 SqlSessionFactory 的数据源）→ 
3. 延迟关闭旧数据源
```
问题出在**步骤2**：
- MyBatis 的 `SqlSessionFactory` 是创建 `SqlSession` 的核心，而 `SqlSession` 绑定了数据源连接；
- 若在旧请求还在执行时（比如已经从旧数据源获取了连接，但还没执行完 SQL），替换了 `SqlSessionFactory` 的数据源，会导致：
    1. 新请求使用新数据源（符合预期）；
    2. 旧请求的 `SqlSession` 可能被中断，或后续操作（如提交事务）使用新数据源，导致数据错乱/连接异常；
    3. 极端情况下，`SqlSessionTemplate`（线程池）中的旧 `SqlSession` 会引用新数据源，引发类型/连接错误。

简单说：**关闭旧数据源是“后续风险”，而替换 MyBatis 数据源是“即时风险”**。

### 二、解决思路：让 MyBatis 平滑切换（核心是“双数据源共存+请求隔离”）
最优方案是：**不直接替换 SqlSessionFactory 中的数据源，而是让 MyBatis 支持“数据源动态路由”**，新请求走新数据源，旧请求走完后自然切换到新数据源。具体分三步：

#### 1. 核心改造：实现动态数据源路由（替代直接替换）
先定义一个“动态路由数据源”，它能在运行时切换底层数据源，且保证同一请求内的数据源不变（避免事务内切换）：
```java
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;
import org.springframework.transaction.support.TransactionSynchronizationManager;

/**
 * 动态路由数据源：支持运行时切换，且绑定当前线程（避免事务内切换）
 */
public class DynamicRoutingDataSource extends AbstractRoutingDataSource {
    // 线程本地变量：存储当前线程使用的数据源标识
    private static final ThreadLocal<String> CURRENT_DS_KEY = new ThreadLocal<>();
    // 默认数据源标识（新数据源）
    private String defaultDsKey = "new";
    // 旧数据源（用于兼容未完成的旧请求）
    private DataSource oldDataSource;
    // 新数据源（默认使用）
    private DataSource newDataSource;

    @Override
    protected Object determineCurrentLookupKey() {
        // 优先使用线程绑定的标识，无则用默认（新数据源）
        String key = CURRENT_DS_KEY.get();
        return key == null ? defaultDsKey : key;
    }

    // ========== 核心方法：切换数据源 ==========
    /**
     * 切换到新数据源（所有新请求默认走这里）
     */
    public void switchToNewDataSource(DataSource newDs) {
        this.newDataSource = newDs;
        // 更新路由表
        setTargetDataSources(Map.of("new", newDs, "old", this.oldDataSource));
        afterPropertiesSet(); // 刷新路由表
        this.defaultDsKey = "new";
        log.info("动态数据源已切换为新数据源");
    }

    /**
     * 保存旧数据源（供未完成的旧请求使用）
     */
    public void keepOldDataSource(DataSource oldDs) {
        this.oldDataSource = oldDs;
        setTargetDataSources(Map.of("new", this.newDataSource, "old", oldDs));
        afterPropertiesSet();
        log.info("已保存旧数据源，供未完成请求使用");
    }

    /**
     * 绑定当前线程到旧数据源（仅旧请求使用）
     */
    public static void bindCurrentThreadToOldDs() {
        CURRENT_DS_KEY.set("old");
    }

    /**
     * 解绑当前线程的数据源标识（请求结束后调用）
     */
    public static void unbindCurrentThreadDs() {
        CURRENT_DS_KEY.remove();
    }

    // ========== 初始化/关闭 ==========
    public void init(DataSource initialDs) {
        this.newDataSource = initialDs;
        setTargetDataSources(Map.of("new", initialDs));
        afterPropertiesSet();
        log.info("动态数据源初始化完成，默认使用初始数据源");
    }

    /**
     * 清理旧数据源（所有旧请求完成后调用）
     */
    public void clearOldDataSource() {
        this.oldDataSource = null;
        setTargetDataSources(Map.of("new", this.newDataSource));
        afterPropertiesSet();
        log.info("已清理旧数据源，仅保留新数据源");
    }
}
```

#### 2. 改造初始化逻辑：用动态数据源替代原 ShardingDataSource
项目启动时，先初始化 `DynamicRoutingDataSource`，并将其作为 MyBatis 的默认数据源：
```java
/**
 * 初始化动态数据源（项目启动时执行）
 */
@Bean(SHARDING_DATASOURCE_BEAN_NAME)
public DataSource initDynamicRoutingDataSource() {
    // 1. 构建初始的 ShardingDataSource（原有逻辑）
    DataSource initialShardingDs = buildInitialShardingDataSource();
    
    // 2. 初始化动态路由数据源
    DynamicRoutingDataSource dynamicDs = new DynamicRoutingDataSource();
    dynamicDs.init(initialShardingDs);
    
    // 3. 将动态数据源设置到 SqlSessionFactory（替代原有直接设置）
    setDataSourceToSqlSessionFactory(dynamicDs);
    
    return dynamicDs;
}
```

#### 3. 改造 Nacos 监听逻辑：平滑切换而非直接替换
核心是：**不替换 SqlSessionFactory 的数据源，而是更新动态数据源的路由规则**，并让旧请求绑定旧数据源：
```java
configService.addListener(dataId, group, new Listener() {
    @Override
    public void receiveConfigInfo(String configContent) {
        synchronized (refreshLock) {
            try {
                // ===== 原有逻辑：解析配置、构建新数据源 =====
                Map<String, Object> flatConfigMap = ConfigParserHandler.getInstance()
                        .parseConfig(configContent, ConfigFileTypeEnum.of(extension));
                ShardingRuleConfiguration shardingRuleConfig = buildUniversalShardingRuleConfig(flatConfigMap);
                Map<String, DataSource> actualDataSources = buildUniversalDataSources(flatConfigMap);
                DataSource newShardingDataSource = createNewShardingDataSource(flatConfigMap, actualDataSources, shardingRuleConfig);

                // ===== 核心改造：获取动态数据源，平滑切换 =====
                // 1. 获取已初始化的动态路由数据源（不再移除/注册新Bean）
                DynamicRoutingDataSource dynamicDs = (DynamicRoutingDataSource) getOldShardingDataSource();
                if (dynamicDs == null) {
                    log.error("动态数据源未初始化，切换失败");
                    return;
                }

                // 2. 保存旧数据源（供未完成的旧请求使用）
                DataSource oldDataSource = dynamicDs.getNewDataSource(); // 获取当前正在使用的数据源（旧）
                dynamicDs.keepOldDataSource(oldDataSource);

                // 3. 切换动态数据源的默认路由到新数据源（新请求走新数据源）
                dynamicDs.switchToNewDataSource(newShardingDataSource);

                // ===== 旧数据源关闭：结合之前的计数+延迟逻辑 =====
                // 等待旧请求完成后，清理旧数据源并关闭
                scheduleGracefulOldDataSourceShutdown(oldDataSource, dynamicDs);

                log.info("数据源平滑切换完成：新请求走新数据源，旧请求继续使用旧数据源");
            } catch (Exception e) {
                log.error("数据源切换失败", e);
            }
        }
    }
});
```

#### 4. 关键补充：拦截器绑定旧请求到旧数据源
通过 MyBatis 拦截器/ Spring 拦截器，让“切换前已开始的请求”绑定到旧数据源：
```java
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 请求拦截器：绑定旧请求到旧数据源
 */
public class DataSourceBindingInterceptor implements HandlerInterceptor {
    // 标记是否正在切换数据源（原子布尔）
    private final AtomicBoolean isSwitchingDs = new AtomicBoolean(false);
    // 切换开始时间（用于判断请求是否是切换前的旧请求）
    private volatile long switchStartTime;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 如果正在切换数据源，且请求是切换前开始的 → 绑定到旧数据源
        if (isSwitchingDs.get() && System.currentTimeMillis() < switchStartTime + 1000) {
            DynamicRoutingDataSource.bindCurrentThreadToOldDs();
            log.debug("旧请求绑定到旧数据源");
        }
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 请求结束后解绑
        DynamicRoutingDataSource.unbindCurrentThreadDs();
    }

    // 切换数据源前调用：标记开始切换
    public void markDsSwitchStart() {
        isSwitchingDs.set(true);
        switchStartTime = System.currentTimeMillis();
    }

    // 切换完成后调用：标记结束切换
    public void markDsSwitchEnd() {
        isSwitchingDs.set(false);
    }
}
```
在 Nacos 监听逻辑中加入拦截器标记：
```java
// 切换数据源前标记
dataSourceBindingInterceptor.markDsSwitchStart();
try {
    dynamicDs.keepOldDataSource(oldDataSource);
    dynamicDs.switchToNewDataSource(newShardingDataSource);
} finally {
    // 切换完成后取消标记
    dataSourceBindingInterceptor.markDsSwitchEnd();
}
```

### 三、核心改造的关键说明
1. **为什么能避免请求失败？**
    - 动态路由数据源保证：**同一请求内的所有操作使用同一个数据源**（旧请求绑定旧数据源，新请求用新数据源）；
    - SqlSessionFactory 不再被修改，始终引用动态数据源，避免了“替换数据源导致的连接中断”；
    - 旧数据源只有在所有旧请求完成后才被清理/关闭，从根本上杜绝了“正在执行的请求丢失数据源”。

2. **对比原有逻辑的核心优化**
3. 
   | 原有逻辑 | 改造后逻辑 |
   |----------|------------|
   | 直接替换 SqlSessionFactory 的数据源 → 旧请求中断 | 动态路由数据源 → 新旧请求隔离，无中断 |
   | 移除旧 Bean → 可能导致容器内 Bean 引用异常 | 复用动态数据源 Bean → 容器无感知 |
   | 仅延迟关闭旧数据源 → 仍有切换风险 | 计数+线程绑定+延迟关闭 → 零中断 |

3. **补充：旧数据源清理时机**
   在 `scheduleGracefulOldDataSourceShutdown` 中，关闭旧数据源前先清理动态数据源中的旧数据源引用：
   ```java
   private void scheduleGracefulOldDataSourceShutdown(DataSource oldDataSource, DynamicRoutingDataSource dynamicDs) {
       shutdownScheduler.schedule(() -> {
           // 等待旧请求完成（计数归0）
           boolean isNoUse = waitUntilOldDataSourceNoUse();
           if (isNoUse) {
               // 1. 清理动态数据源中的旧数据源引用
               dynamicDs.clearOldDataSource();
               // 2. 关闭旧数据源
               closeDataSourceSafely(oldDataSource);
               log.info("旧数据源已清理并关闭");
           }
       }, INIT_DELAY_SECONDS, TimeUnit.SECONDS);
   }
   ```

### 四、总结
1. **核心风险点**：不是“关闭旧数据源”，而是**替换 MyBatis 组件中的数据源**，导致正在执行的请求丢失数据源引用；
2. **根本解决方案**：使用 `AbstractRoutingDataSource` 实现动态路由，让新旧数据源共存，新请求走新源、旧请求走完旧源；
3. **安全保障**：线程绑定+计数等待+延迟关闭，三重保障旧请求执行完成后再清理旧数据源，实现“无感知切换”。

这个方案是生产环境中 MyBatis + 动态数据源切换的行业最佳实践，能彻底解决“数据源切换导致请求失败”的问题。你可以根据项目实际情况（比如是否用 Spring MVC/ WebFlux）调整拦截器实现，核心的动态路由逻辑不变。