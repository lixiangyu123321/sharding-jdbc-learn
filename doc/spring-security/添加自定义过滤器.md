你现在关注的是 Spring Security 中如何通过 `HttpSecurity` 的 `addFilterBefore`/`addFilterAfter`/`addFilterAt` 方法，向 `SecurityFilterChain` 中添加自定义 Filter——这是在默认安全过滤器基础上定制化安全逻辑的核心方式，下面我会把这三个方法的用法、场景、注意事项讲清楚，结合示例让你能直接落地。

### 一、核心前提：先理解 `SecurityFilterChain` 的过滤器执行顺序
Spring Security 的 `SecurityFilterChain` 内部的过滤器是**严格按固定顺序执行**的（这是框架的核心规则），比如：
1. `WebAsyncManagerIntegrationFilter`（最前）→ 2. `SecurityContextPersistenceFilter` → 3. `HeaderWriterFilter` → 4. `CsrfFilter` → 5. `LogoutFilter` → 6. `UsernamePasswordAuthenticationFilter` → ... → 最后 `FilterSecurityInterceptor`（授权拦截）。

`addFilterBefore`/`addFilterAfter`/`addFilterAt` 的核心作用，就是基于这个“固定顺序”，把自定义 Filter 插入到指定位置——这也是它们和 Servlet 原生 Filter 注册的本质区别（原生 Filter 只能指定 `order`，无法精准对标 Security 内置过滤器）。

### 二、三个方法的核心用法与场景
#### 1. `addFilterBefore(Filter, Class<? extends Filter>)`：在指定过滤器**之前**插入
- **作用**：让自定义 Filter 比目标内置过滤器先执行；
- **典型场景**：需要在框架核心逻辑前做预处理（比如解析自定义 Token、预处理请求头、记录请求日志）；
- **示例**：在 `UsernamePasswordAuthenticationFilter` 前添加自定义 JWT 认证过滤器（先校验 JWT，再走表单认证）。

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    // 自定义 JWT 认证过滤器
    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
            // 在 UsernamePasswordAuthenticationFilter 之前添加 JWT 过滤器
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
            .formLogin(); // 保留表单登录

        return http.build();
    }
}
```

#### 2. `addFilterAfter(Filter, Class<? extends Filter>)`：在指定过滤器**之后**插入
- **作用**：让自定义 Filter 比目标内置过滤器后执行；
- **典型场景**：需要在框架核心逻辑后做后置处理（比如记录认证成功后的日志、补充响应头、清理临时数据）；
- **示例**：在 `FilterSecurityInterceptor`（授权拦截器）后添加自定义日志过滤器（记录授权结果）。

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    // 自定义授权日志过滤器
    @Bean
    public AuthLogFilter authLogFilter() {
        return new AuthLogFilter();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
            // 在 FilterSecurityInterceptor 之后添加日志过滤器
            .addFilterAfter(authLogFilter(), FilterSecurityInterceptor.class)
            .formLogin();

        return http.build();
    }
}
```

#### 3. `addFilterAt(Filter, Class<? extends Filter>)`：替换指定过滤器
- **作用**：用自定义 Filter 完全替换框架内置的某个过滤器（相当于“覆盖”原有逻辑）；
- **典型场景**：内置过滤器的逻辑不满足需求，需要完全重写（比如替换默认的 `CsrfFilter` 为自定义的 CSRF 校验逻辑）；
- **注意**：替换的过滤器必须和原过滤器实现相同的接口/功能，否则会破坏 Security 逻辑。

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    // 自定义 CSRF 过滤器
    @Bean
    public CustomCsrfFilter customCsrfFilter() {
        return new CustomCsrfFilter();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
            // 用自定义 CSRF 过滤器替换框架默认的 CsrfFilter
            .addFilterAt(customCsrfFilter(), CsrfFilter.class)
            .formLogin();

        return http.build();
    }
}
```

### 三、关键注意事项（避免踩坑）
1. **必须指定“锚点过滤器”的准确类型**
    - 传入的第二个参数必须是 Spring Security 内置过滤器的 `Class`（如 `UsernamePasswordAuthenticationFilter.class`），不能是自定义 Filter；
    - 如果写错类型（比如拼错类名、传入不存在的过滤器），会抛出 `IllegalArgumentException`。

2. **自定义 Filter 需符合 Spring Security 规范**
    - 如果自定义 Filter 是认证相关的（如 JWT 过滤器），建议继承 `OncePerRequestFilter`（确保每个请求只执行一次）；
    - 认证过滤器需要手动处理 `SecurityContext`（比如把认证后的用户信息存入 `SecurityContextHolder`）。

3. **多个自定义 Filter 的顺序**
    - 如果多次调用 `addFilterBefore`/`addFilterAfter`，按调用顺序排列（比如先调用 `addFilterBefore(A, X)`，再调用 `addFilterBefore(B, X)`，则 B 在 A 之前执行）；
    - 可通过 `http.getSharedObject(FilterComparator.class)` 查看完整的过滤器顺序。

4. **和 Servlet 原生 Filter 的区别**
    - 这里添加的 Filter 是 `SecurityFilterChain` 内部的，由 `FilterChainProxy` 管理，能享受 Spring Security 的上下文（如 `SecurityContext`）；
    - Servlet 原生 Filter 是注册到 Servlet 容器的，在 `FilterChainProxy` 之前执行，无法直接访问 Security 上下文。

### 四、总结
1. **核心作用**：`addFilterBefore`/`addFilterAfter`/`addFilterAt` 是向 `SecurityFilterChain` 中添加/替换自定义 Filter 的核心方法，能精准控制自定义 Filter 相对于 Spring Security 内置过滤器的执行顺序；
2. **使用场景**：
    - 前置插入（`addFilterBefore`）：预处理/前置校验（如 JWT 认证）；
    - 后置插入（`addFilterAfter`）：后置处理/日志记录；
    - 替换（`addFilterAt`）：完全重写内置过滤器逻辑；
3. **关键原则**：必须基于 Spring Security 内置过滤器的固定顺序选择“锚点”，确保自定义逻辑融入框架的安全流程，而非破坏原有逻辑。

这些方法的设计，也是 `FilterChainProxy` 灵活性的体现——既能复用框架的默认安全过滤器，又能按需定制，无需从零构建整个安全流程。