你问到的“重新认证时新的登录请求，如何和上次被拦截的请求匹配”，核心答案是：**通过 `HttpSession` 来关联两次请求（被拦截的请求 + 登录请求），`RequestCache` 把被拦截的请求信息存在 `HttpSession` 里，登录请求和它共用同一个 `HttpSession`，因此能精准匹配到对应的缓存请求**。

下面我用“请求链路+技术细节”拆解这个过程，让你看清两次请求是如何关联的：

### 一、先明确：两次请求的核心关联载体——`HttpSession`
浏览器和服务器交互时，**同一个浏览器会话会共用一个 `HttpSession`**（通过 Cookie 里的 `JSESSIONID` 标识），这是两次请求能匹配的基础：
- 被拦截的请求（如 `/admin/orders`）：服务器为这个请求创建/使用一个 `HttpSession`，`RequestCache` 把请求信息存在这个 `HttpSession` 里；
- 登录请求（如 POST `/login`）：同一个浏览器发起的登录请求，会携带相同的 `JSESSIONID`，服务器能找到同一个 `HttpSession`，从而读取到里面缓存的请求信息。

### 二、完整链路：被拦截请求 → 登录请求 → 重定向的匹配过程
#### 步骤1：用户访问 `/admin/orders`（未登录，被拦截）
1. 浏览器发起 GET `/admin/orders` 请求，携带 `JSESSIONID=abc123`（如果没有则服务器新建，返回给浏览器）；
2. 服务器检测到用户未认证，抛出 `AuthenticationException`；
3. `ExceptionTranslationFilter` 触发：
    - 调用 `RequestCache`（默认 `HttpSessionRequestCache`），把 `/admin/orders` 的请求信息（URL、参数等）存入 `HttpSession`（`JSESSIONID=abc123` 对应的会话）；
    - 重定向到 `/login` 页面（响应头 `Location: /login`）。

#### 步骤2：用户在 `/login` 页面提交登录请求（POST `/login`）
1. 浏览器发起 POST `/login` 请求，**依然携带 `JSESSIONID=abc123`**（同一个会话）；
2. 服务器通过 `JSESSIONID` 找到对应的 `HttpSession`，验证用户名密码；
3. 登录成功后，触发 `SavedRequestAwareAuthenticationSuccessHandler`：
    - 该处理器调用 `RequestCache`，从 `JSESSIONID=abc123` 的 `HttpSession` 中读取缓存的 `/admin/orders` 请求信息；
    - 生成重定向响应（`Location: /admin/orders`），返回给浏览器。

#### 步骤3：浏览器跳转到 `/admin/orders`
1. 浏览器携带 `JSESSIONID=abc123` 发起 GET `/admin/orders` 请求；
2. 此时用户已认证，请求正常执行，最终展示目标页面。

### 三、关键细节：为什么两次请求能精准匹配？
1. **`JSESSIONID` 是“唯一标识”**：
   浏览器会自动在同域名下携带 `JSESSIONID` Cookie，服务器通过这个 ID 找到对应的 `HttpSession`，而缓存的请求信息就存在这个 `HttpSession` 里——相当于给每个用户的“被拦截请求”贴了唯一的“标签”，登录请求带着同一个标签，就能找到对应的缓存。

2. **`RequestCache` 只关联当前会话**：
   不同用户的 `HttpSession` 相互隔离，用户 A 的缓存请求不会被用户 B 读取到，保证了安全性和准确性。

3. **登录请求完成后缓存会清除**：
   一旦重定向到 `/admin/orders`，`RequestCache` 会立即从 `HttpSession` 中删除缓存的请求信息，避免同一个缓存被重复使用（比如用户刷新登录页，不会再次跳转到 `/admin/orders`）。

### 四、通俗类比：用“取号单”理解匹配过程
1. 你去银行办业务（访问 `/admin/orders`），保安说“先办卡（登录）”，给你一张**带编号的取号单**（`JSESSIONID=abc123`），并记下你要办的业务（缓存请求信息）；
2. 你去柜台办卡（登录请求），出示取号单（携带 `JSESSIONID=abc123`）；
3. 办卡成功后，柜员根据取号单的编号，找到你要办的业务（读取缓存请求），直接带你去对应的窗口（重定向到 `/admin/orders`）；
4. 业务办完后，取号单被收回（清除缓存），不会被重复使用。

### 总结
1. **匹配核心**：两次请求（被拦截请求 + 登录请求）通过 `HttpSession`（`JSESSIONID`）关联，`RequestCache` 把被拦截请求存在 `HttpSession` 里，登录请求从同一个 `HttpSession` 读取；
2. **关键载体**：`JSESSIONID` Cookie 是浏览器和服务器之间的“会话标识”，保证了两次请求能找到同一个 `HttpSession`；
3. **安全性**：不同用户的 `HttpSession` 隔离，缓存的请求信息不会串用，且使用后立即清除，避免重复重定向。

这个机制本质是利用 HTTP 会话的“状态保持”特性，解决了“无状态 HTTP 请求”下的“请求关联”问题——既保证了安全，又实现了流畅的用户体验。