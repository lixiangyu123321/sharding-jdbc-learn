你想知道与全局异常处理器相关的核心注解，核心结论先明确：实现全局异常处理的核心注解是 `@RestControllerAdvice`（或 `@ControllerAdvice`） + `@ExceptionHandler`，前者负责“全局拦截”，后者负责“指定处理哪种异常”。

### 一、核心注解详解
#### 1. @ControllerAdvice（基础版）
- **作用**：标记一个类为“全局控制器增强类”，可以拦截所有 `@Controller` 注解的控制器抛出的异常，还能实现全局数据绑定、全局数据预处理。
- **核心特性**：
    - 全局生效：无需在每个控制器中重复写异常处理逻辑；
    - 可指定范围：通过 `basePackages`/`assignableTypes` 限定只处理特定包/类的异常，示例：
      ```java
      // 仅处理 com.example.controller 包下的控制器异常
      @ControllerAdvice(basePackages = "com.example.controller")
      public class GlobalExceptionHandler {}
      ```
- **局限性**：处理完异常后，默认返回视图（ModelAndView），不适合 REST API 接口场景。

#### 2. @RestControllerAdvice（REST API 首选）
- **作用**：`@ControllerAdvice + @ResponseBody` 的组合注解，专门用于 RESTful 接口的全局异常处理，处理结果会直接序列化为 JSON/XML 返回（而非视图），是 Spring Boot 中最常用的全局异常处理器注解。
- **使用场景**：前后端分离项目、纯 API 接口项目（几乎所有现代 Spring Boot 项目都用这个）。

#### 3. @ExceptionHandler（核心匹配注解）
- **作用**：标注在方法上，指定该方法处理“哪种异常”（可指定单个/多个异常类型），是全局异常处理的“核心匹配规则”。
- **核心特性**：
    - 精准匹配：优先匹配最具体的异常类型（比如先匹配 `BusinessException`，再匹配 `RuntimeException`，最后匹配 `Exception`）；
    - 多异常匹配：可同时处理多种异常，示例：
      ```java
      // 同时处理空指针和数组越界异常
      @ExceptionHandler({NullPointerException.class, ArrayIndexOutOfBoundsException.class})
      public Result<?> handleCommonRuntimeException(Exception e) {
          log.error("运行时异常", e);
          return Result.fail(500, "运行时错误：" + e.getMessage());
      }
      ```

### 二、辅助注解（可选）
#### 1. @ResponseStatus
- **作用**：给异常处理方法指定返回的 HTTP 状态码（比如 400 表示参数错误，404 表示资源不存在，500 表示服务器错误），让响应更符合 HTTP 规范。
- **示例**：
  ```java
  @RestControllerAdvice
  public class GlobalExceptionHandler {
      // 处理业务异常，返回 HTTP 400 状态码
      @ExceptionHandler(BusinessException.class)
      @ResponseStatus(HttpStatus.BAD_REQUEST) // HTTP 400
      public Result<?> handleBusinessException(BusinessException e) {
          return Result.fail(e.getCode(), e.getMessage());
      }

      // 处理资源不存在异常，返回 HTTP 404 状态码
      @ExceptionHandler(ResourceNotFoundException.class)
      @ResponseStatus(HttpStatus.NOT_FOUND) // HTTP 404
      public Result<?> handleResourceNotFound(ResourceNotFoundException e) {
          return Result.fail(404, e.getMessage());
      }
  }
  ```

### 三、完整示例（核心注解组合使用）
```java
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

/**
 * 全局异常处理器核心示例（REST API 场景）
 */
@Slf4j
@RestControllerAdvice // 核心：全局拦截 + 返回JSON
public class GlobalExceptionHandler {

    // 1. 处理自定义业务异常（HTTP 400）
    @ExceptionHandler(BusinessException.class) // 匹配业务异常
    @ResponseStatus(HttpStatus.BAD_REQUEST)    // 自定义HTTP状态码
    public Result<?> handleBusinessException(BusinessException e) {
        log.error("业务异常：{}", e.getMessage(), e);
        return Result.fail(e.getCode(), e.getMessage());
    }

    // 2. 处理系统通用异常（HTTP 500）
    @ExceptionHandler(Exception.class) // 兜底匹配所有异常
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) // HTTP 500
    public Result<?> handleSystemException(Exception e) {
        log.error("系统异常", e);
        return Result.fail(500, "服务器内部错误，请联系管理员");
    }
}
```

### 总结
1. **核心注解**：
    - `@RestControllerAdvice`：REST API 全局异常处理器的核心注解（全局拦截 + JSON 返回）；
    - `@ExceptionHandler`：指定方法处理的异常类型（精准匹配）；
    - `@ControllerAdvice`：非 REST 场景（返回视图）的全局拦截注解（极少用）。
2. **辅助注解**：
    - `@ResponseStatus`：自定义异常处理方法的 HTTP 状态码，让响应更规范。

简单记：全局异常处理的核心是“`@RestControllerAdvice` 搭架子，`@ExceptionHandler` 定规则”，前者管“全局拦截”，后者管“处理哪种异常”。